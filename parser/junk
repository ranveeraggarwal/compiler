    parse(): Parsing starts
    push(state 0)
    ==
    nextToken(): using `MNEMONIC'
    lookup(0, `MNEMONIC'): default reduction by rule 7
    executeAction(): of rule 7 ...
    ... action of rule 7 completed
    pop(0) from stack having size 1
    pop(): next state: 0, token: `optional_label'
    reduce(): by rule 7 to N-terminal `optional_label'
    ==
    lookup(0, `optional_label'): shift 4 (`optional_label' processed)
    push(state 4)
    ==
    lookup(4, `MNEMONIC'): shift 7 (`MNEMONIC' processed)
    push(state 7)
    ==
    nextToken(): using `REGISTER'
    lookup(7, `REGISTER'): shift 13 (`REGISTER' processed)
    push(state 13)
    ==
    lookup(13, `_UNDETERMINED_'): default reduction by rule 11
    executeAction(): of rule 11 ...
    ... action of rule 11 completed
    pop(1) from stack having size 4
    pop(): next state: 7, token: `register_exp'
    reduce(): by rule 11 to N-terminal `register_exp'
    ==
    lookup(7, `register_exp'): shift 11 (`register_exp' processed)
    push(state 11)
    ==
    lookup(11, `_UNDETERMINED_'): default reduction by rule 9
    executeAction(): of rule 9 ...
    ... action of rule 9 completed
    pop(1) from stack having size 4
    pop(): next state: 7, token: `opnd'
    reduce(): by rule 9 to N-terminal `opnd'
    ==
    lookup(7, `opnd'): shift 10 (`opnd' processed)
    push(state 10)
    ==
    nextToken(): using `_EOF_'
    lookup(10, `_EOF_'): default reduction by rule 5
    executeAction(): of rule 5 ...
    ... action of rule 5 completed
    pop(3) from stack having size 4
    pop(): next state: 0, token: `instruction'
    reduce(): by rule 5 to N-terminal `instruction'
    ==
    lookup(0, `instruction'): shift 3 (`instruction' processed)
    push(state 3)
    ==
    lookup(3, `_EOF_'): default reduction by rule 2
    executeAction(): of rule 2 ...
    ... action of rule 2 completed
    pop(1) from stack having size 2
    pop(): next state: 0, token: `instruction_list'
    reduce(): by rule 2 to N-terminal `instruction_list'
    ==
    lookup(0, `instruction_list'): shift 2 (`instruction_list' processed)
    push(state 2)
    ==
    lookup(2, `_EOF_'): default reduction by rule 1
    executeAction(): of rule 1 ...
    ... action of rule 1 completed
    pop(1) from stack having size 2
    pop(): next state: 0, token: `program'
    reduce(): by rule 1 to N-terminal `program'
    ==
    lookup(0, `program'): shift 1 (`program' processed)
    push(state 1)
    ==
    lookup(1, `_EOF_'): ACCEPT
    ACCEPT(): Parsing successful
    parse(): returns 0
